{
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
  "name": "Parsley",
  "scopeName": "source.parsley",
  "patterns": [
    {
      "include": "#comments"
    },
    {
      "include": "#keywords"
    },
    {
      "include": "#operators-special"
    },
    {
      "include": "#datetime-literals"
    },
    {
      "include": "#duration-literals"
    },
    {
      "include": "#money-literals"
    },
    {
      "include": "#stdlib-paths"
    },
    {
      "include": "#path-template-literals"
    },
    {
      "include": "#url-literals"
    },
    {
      "include": "#path-literals"
    },
    {
      "include": "#special-literals"
    },
    {
      "include": "#regex-literals"
    },
    {
      "include": "#raw-template-literals"
    },
    {
      "include": "#template-literals"
    },
    {
      "include": "#strings"
    },
    {
      "include": "#numbers"
    },
    {
      "include": "#constants"
    },
    {
      "include": "#builtins"
    },
    {
      "include": "#tags"
    },
    {
      "include": "#operators"
    },
    {
      "include": "#punctuation"
    }
  ],
  "repository": {
    "comments": {
      "patterns": [
        {
          "name": "comment.line.double-slash.parsley",
          "match": "//.*$"
        }
      ]
    },
    "keywords": {
      "patterns": [
        {
          "name": "keyword.control.parsley",
          "match": "\\b(if|else|return|for|in|check|stop|skip|try)\\b"
        },
        {
          "name": "keyword.other.parsley",
          "match": "\\b(let|fn|function|as|export|import|and|or|not)\\b"
        }
      ]
    },
    "constants": {
      "patterns": [
        {
          "name": "constant.language.parsley",
          "match": "\\b(true|false|null)\\b"
        },
        {
          "name": "variable.language.underscore.parsley",
          "match": "\\b_\\b"
        }
      ]
    },
    "strings": {
      "patterns": [
        {
          "name": "string.quoted.double.parsley",
          "begin": "\"",
          "end": "\"",
          "patterns": [
            {
              "name": "constant.character.escape.parsley",
              "match": "\\\\([ntr\\\\\"'{}])"
            },
            {
              "name": "meta.embedded.line.parsley",
              "begin": "(?<!\\\\)\\{",
              "end": "\\}",
              "beginCaptures": {
                "0": {
                  "name": "punctuation.definition.template-expression.begin.parsley"
                }
              },
              "endCaptures": {
                "0": {
                  "name": "punctuation.definition.template-expression.end.parsley"
                }
              },
              "patterns": [
                {
                  "include": "$self"
                }
              ]
            }
          ]
        }
      ]
    },
    "template-literals": {
      "patterns": [
        {
          "name": "string.template.parsley",
          "begin": "`",
          "end": "`",
          "patterns": [
            {
              "name": "constant.character.escape.parsley",
              "match": "\\\\([ntr\\\\`{}])"
            },
            {
              "name": "meta.embedded.line.parsley",
              "begin": "(?<!\\\\)\\{",
              "end": "\\}",
              "beginCaptures": {
                "0": {
                  "name": "punctuation.definition.template-expression.begin.parsley"
                }
              },
              "endCaptures": {
                "0": {
                  "name": "punctuation.definition.template-expression.end.parsley"
                }
              },
              "patterns": [
                {
                  "include": "$self"
                }
              ]
            }
          ]
        }
      ]
    },
    "raw-template-literals": {
      "patterns": [
        {
          "name": "string.quoted.single.raw.parsley",
          "begin": "'",
          "end": "'",
          "patterns": [
            {
              "name": "constant.character.escape.parsley",
              "match": "\\\\([ntr\\\\'@{}])"
            },
            {
              "name": "meta.embedded.line.parsley",
              "begin": "@\\{",
              "end": "\\}",
              "beginCaptures": {
                "0": {
                  "name": "punctuation.definition.template-expression.begin.parsley"
                }
              },
              "endCaptures": {
                "0": {
                  "name": "punctuation.definition.template-expression.end.parsley"
                }
              },
              "patterns": [
                {
                  "include": "$self"
                }
              ]
            }
          ]
        }
      ]
    },
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.float.parsley",
          "match": "\\b\\d+\\.\\d+\\b"
        },
        {
          "name": "constant.numeric.integer.parsley",
          "match": "\\b\\d+\\b"
        }
      ]
    },
    "regex-literals": {
      "patterns": [
        {
          "name": "string.regexp.parsley",
          "begin": "/(?![*/\\s])",
          "end": "/[gimsuvy]*",
          "beginCaptures": {
            "0": {
              "name": "punctuation.definition.string.begin.parsley"
            }
          },
          "endCaptures": {
            "0": {
              "name": "punctuation.definition.string.end.parsley"
            }
          },
          "patterns": [
            {
              "name": "constant.character.escape.parsley",
              "match": "\\\\."
            }
          ]
        }
      ]
    },
    "datetime-literals": {
      "patterns": [
        {
          "comment": "Full datetime: @2024-11-26T14:30:00Z or with timezone offset",
          "name": "constant.other.datetime.parsley",
          "match": "@\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}(:\\d{2})?(\\.\\d+)?(Z|[+-]\\d{2}:\\d{2})?"
        },
        {
          "comment": "Date only: @2024-11-26",
          "name": "constant.other.date.parsley",
          "match": "@\\d{4}-\\d{2}-\\d{2}(?!T)"
        },
        {
          "comment": "Time only: @12:30 or @12:30:45",
          "name": "constant.other.time.parsley",
          "match": "@\\d{1,2}:\\d{2}(:\\d{2})?"
        }
      ]
    },
    "duration-literals": {
      "patterns": [
        {
          "comment": "Duration: @1d, @2h30m, @1y6mo, @-1d (negative)",
          "name": "constant.other.duration.parsley",
          "match": "@-?\\d+[yMwdhms]([0-9yMwdhms]|mo)*"
        }
      ]
    },
    "money-literals": {
      "patterns": [
        {
          "comment": "Money: $100, $12.50, £99.99, €50, ¥1000, EUR#50.00",
          "name": "constant.numeric.money.parsley",
          "match": "([$£€¥]|[A-Z]{3}#)[0-9]+(\\.[0-9]{1,2})?"
        }
      ]
    },
    "stdlib-paths": {
      "patterns": [
        {
          "comment": "Standard library: @std/math, @std/table, etc.",
          "name": "support.module.stdlib.parsley",
          "match": "@std/(table|dev|math|valid|schema|id|api|markdown|mdDoc|html)\\b"
        },
        {
          "comment": "Basil namespace: @basil/http, @basil/auth, @basil",
          "name": "support.module.basil.parsley",
          "match": "@basil(/http|/auth)?\\b"
        }
      ]
    },
    "path-template-literals": {
      "patterns": [
        {
          "comment": "Path/URL templates: @(./path/{expr}), @(https://api.com/{id})",
          "name": "meta.path-template.parsley",
          "begin": "@\\(",
          "end": "\\)",
          "beginCaptures": {
            "0": {
              "name": "punctuation.definition.path-template.begin.parsley"
            }
          },
          "endCaptures": {
            "0": {
              "name": "punctuation.definition.path-template.end.parsley"
            }
          },
          "patterns": [
            {
              "name": "meta.interpolation.parsley",
              "begin": "\\{",
              "end": "\\}",
              "beginCaptures": {
                "0": {
                  "name": "punctuation.definition.interpolation.begin.parsley"
                }
              },
              "endCaptures": {
                "0": {
                  "name": "punctuation.definition.interpolation.end.parsley"
                }
              },
              "patterns": [
                {
                  "include": "#keywords"
                },
                {
                  "include": "#constants"
                },
                {
                  "include": "#strings"
                },
                {
                  "include": "#numbers"
                },
                {
                  "include": "#operators"
                }
              ]
            },
            {
              "name": "constant.other.path.parsley",
              "match": "[^{}]+"
            }
          ]
        }
      ]
    },
    "url-literals": {
      "patterns": [
        {
          "comment": "URL literals: @https://example.com, @http://..., @ftp://...",
          "name": "string.unquoted.url.parsley",
          "match": "@(https?|ftp|file)://[^\\s<>\"{}|\\\\^`\\[\\]]+"
        }
      ]
    },
    "path-literals": {
      "patterns": [
        {
          "comment": "Standard input/output/error streams",
          "name": "constant.other.path.stdio.parsley",
          "match": "@(-|stdin|stdout|stderr|stdio)\\b"
        },
        {
          "comment": "Relative and absolute paths: @./file, @../dir, @/usr/local, @~/home",
          "name": "constant.other.path.parsley",
          "match": "@(\\./|\\.\\./)([^\\s<>\"{}|\\\\^`\\[\\]]*)|@(/|~/)([^\\s<>\"{}|\\\\^`\\[\\]]*)"
        }
      ]
    },
    "special-literals": {
      "patterns": [
        {
          "comment": "Database literals: @sqlite, @postgres, @mysql",
          "name": "support.constant.database.parsley",
          "match": "@(sqlite|postgres|mysql|DB)\\b"
        },
        {
          "comment": "Other special literals: @sftp, @shell",
          "name": "support.constant.special.parsley",
          "match": "@(sftp|shell)\\b"
        },
        {
          "comment": "Time-related: @now, @today, @timeNow, @dateNow",
          "name": "support.constant.time.parsley",
          "match": "@(now|today|timeNow|dateNow)\\b"
        }
      ]
    },
    "operators-special": {
      "patterns": [
        {
          "comment": "File I/O operators: <==, <=/=, ==>, ==>>",
          "name": "keyword.operator.io.parsley",
          "match": "<==|<=/=|==>|==>>"
        },
        {
          "comment": "Database operators: <=?=>, <=??=>, <=!=>, <=#=>",
          "name": "keyword.operator.database.parsley",
          "match": "<=\\?\\?=>|<=\\?=>|<=!=>|<=#=>"
        }
      ]
    },
    "builtins": {
      "patterns": [
        {
          "comment": "Core builtin functions",
          "name": "support.function.builtin.parsley",
          "match": "\\b(import|now|time|url|file|JSON|YAML|CSV|lines|text|bytes|SVG|MD|markdown|dir|fileList|format|regex|match|tag|asset|repr|inspect|describe|toInt|toFloat|toNumber|toString|toDebug|log|logLine|print|println|printf|fail|toArray|toDict|money|builtins|sqlite|postgres|mysql|sftp|shell)\\b(?=\\s*\\()"
        },
        {
          "comment": "Entity name for function definitions",
          "name": "entity.name.function.parsley",
          "match": "\\b([a-zA-Z_][a-zA-Z0-9_]*)(?=\\s*=\\s*fn\\b)"
        }
      ]
    },
    "tags": {
      "patterns": [
        {
          "comment": "HTML/JSX-style tags",
          "name": "meta.tag.parsley",
          "begin": "<(/)?([A-Z][a-zA-Z0-9]*|[a-z][a-zA-Z0-9-]*)?",
          "end": "/?>",
          "beginCaptures": {
            "0": {
              "name": "punctuation.definition.tag.begin.parsley"
            },
            "1": {
              "name": "punctuation.definition.tag.slash.parsley"
            },
            "2": {
              "name": "entity.name.tag.parsley"
            }
          },
          "endCaptures": {
            "0": {
              "name": "punctuation.definition.tag.end.parsley"
            }
          },
          "patterns": [
            {
              "comment": "Tag attributes",
              "name": "entity.other.attribute-name.parsley",
              "match": "\\b[a-zA-Z][a-zA-Z0-9_-]*(?=\\s*=)"
            },
            {
              "comment": "Spread operator in tags",
              "name": "keyword.operator.spread.parsley",
              "match": "\\.\\.\\.[a-zA-Z_][a-zA-Z0-9_]*"
            },
            {
              "include": "#strings"
            },
            {
              "name": "meta.embedded.expression.parsley",
              "begin": "\\{",
              "end": "\\}",
              "beginCaptures": {
                "0": {
                  "name": "punctuation.definition.expression.begin.parsley"
                }
              },
              "endCaptures": {
                "0": {
                  "name": "punctuation.definition.expression.end.parsley"
                }
              },
              "patterns": [
                {
                  "include": "$self"
                }
              ]
            }
          ]
        }
      ]
    },
    "operators": {
      "patterns": [
        {
          "comment": "Regex match operators",
          "name": "keyword.operator.regex.parsley",
          "match": "(!~|~)"
        },
        {
          "comment": "Nullish coalescing",
          "name": "keyword.operator.nullish.parsley",
          "match": "\\?\\?"
        },
        {
          "comment": "Comparison operators",
          "name": "keyword.operator.comparison.parsley",
          "match": "(==|!=|<=|>=|<(?![a-zA-Z=])|>(?![>/=]))"
        },
        {
          "comment": "Logical operators",
          "name": "keyword.operator.logical.parsley",
          "match": "(&&|\\|\\||!(?![~=]))"
        },
        {
          "comment": "Arithmetic operators",
          "name": "keyword.operator.arithmetic.parsley",
          "match": "(\\+\\+|\\+|-|\\*|/|%)"
        },
        {
          "comment": "Range operator",
          "name": "keyword.operator.range.parsley",
          "match": "\\.\\."
        },
        {
          "comment": "Assignment operator",
          "name": "keyword.operator.assignment.parsley",
          "match": "=(?![=>])"
        },
        {
          "comment": "Spread/rest operator",
          "name": "keyword.operator.spread.parsley",
          "match": "\\.\\.\\."
        }
      ]
    },
    "punctuation": {
      "patterns": [
        {
          "name": "punctuation.separator.comma.parsley",
          "match": ","
        },
        {
          "name": "punctuation.terminator.statement.parsley",
          "match": ";"
        },
        {
          "name": "meta.brace.square.parsley",
          "match": "[\\[\\]]"
        },
        {
          "name": "meta.brace.round.parsley",
          "match": "[\\(\\)]"
        },
        {
          "name": "meta.brace.curly.parsley",
          "match": "[\\{\\}]"
        },
        {
          "name": "punctuation.accessor.parsley",
          "match": "\\."
        },
        {
          "name": "punctuation.separator.colon.parsley",
          "match": ":"
        },
        {
          "name": "punctuation.separator.question.parsley",
          "match": "\\?"
        }
      ]
    }
  }
}