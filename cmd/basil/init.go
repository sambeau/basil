package main

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
)

const indexParsContent = `<h1>ðŸŒ¿ Hello from Basil ðŸ‘‹</h1>
`

const gitignoreContent = `# Basil log files
logs/
*.log

# SQLite databases
*.db
*.db-shm
*.db-wal
`

const basilYAMLTemplate = `# Basil Configuration
# Generated by: basil --init

server:
  host: localhost
  port: 8080

# Site mode - filesystem-based routing
# Files in site/ are served at their path (e.g., site/index.pars â†’ /)
site: ./site

# Public directory for static files (CSS, JS, images)
public_dir: ./public

logging:
  level: info
  format: text
  output: ./logs/basil.log  # Log to file (use 'stderr' for console)
  parsley:
    output: ./logs/parsley.log
`

// runInitCommand creates a new Basil project in the specified folder.
func runInitCommand(folderName string, stdout, stderr io.Writer) error {
	// Convert to absolute path for clearer error messages
	absPath, err := filepath.Abs(folderName)
	if err != nil {
		return fmt.Errorf("invalid path '%s': %w", folderName, err)
	}

	// Check if path exists
	info, err := os.Stat(absPath)
	if err == nil {
		// Path exists - check if it's a file or non-empty directory
		if !info.IsDir() {
			return fmt.Errorf("path '%s' exists but is a file, not a folder", folderName)
		}

		// Check if directory is empty
		entries, err := os.ReadDir(absPath)
		if err != nil {
			return fmt.Errorf("failed to read directory '%s': %w", folderName, err)
		}
		if len(entries) > 0 {
			return fmt.Errorf("folder '%s' is not empty - use an empty folder or choose a different name", folderName)
		}
	} else if !os.IsNotExist(err) {
		// Some other error (permissions, etc.)
		return fmt.Errorf("failed to access path '%s': %w", folderName, err)
	}

	// Create project directory if it doesn't exist
	if err := os.MkdirAll(absPath, 0755); err != nil {
		return fmt.Errorf("failed to create folder '%s': %w", folderName, err)
	}

	// Create subdirectories
	siteDir := filepath.Join(absPath, "site")
	if err := os.MkdirAll(siteDir, 0755); err != nil {
		return fmt.Errorf("failed to create site folder: %w", err)
	}

	publicDir := filepath.Join(absPath, "public")
	if err := os.MkdirAll(publicDir, 0755); err != nil {
		return fmt.Errorf("failed to create public folder: %w", err)
	}

	logsDir := filepath.Join(absPath, "logs")
	if err := os.MkdirAll(logsDir, 0755); err != nil {
		return fmt.Errorf("failed to create logs folder: %w", err)
	}

	// Create index.pars
	indexPath := filepath.Join(siteDir, "index.pars")
	if err := os.WriteFile(indexPath, []byte(indexParsContent), 0644); err != nil {
		return fmt.Errorf("failed to create index.pars: %w", err)
	}

	// Create basil.yaml
	yamlPath := filepath.Join(absPath, "basil.yaml")
	if err := os.WriteFile(yamlPath, []byte(basilYAMLTemplate), 0644); err != nil {
		return fmt.Errorf("failed to create basil.yaml: %w", err)
	}

	// Create .gitignore
	gitignorePath := filepath.Join(absPath, ".gitignore")
	if err := os.WriteFile(gitignorePath, []byte(gitignoreContent), 0644); err != nil {
		return fmt.Errorf("failed to create .gitignore: %w", err)
	}

	// Print success message
	fmt.Fprintf(stdout, "Created new Basil project in '%s'\n\n", folderName)
	fmt.Fprintf(stdout, "  %s/\n", folderName)
	fmt.Fprintf(stdout, "  â”œâ”€â”€ .gitignore      Git ignore patterns\n")
	fmt.Fprintf(stdout, "  â”œâ”€â”€ basil.yaml      Configuration\n")
	fmt.Fprintf(stdout, "  â”œâ”€â”€ site/           Handlers (filesystem routing)\n")
	fmt.Fprintf(stdout, "  â”‚   â””â”€â”€ index.pars  Homepage\n")
	fmt.Fprintf(stdout, "  â”œâ”€â”€ public/         Static files (CSS, JS, images)\n")
	fmt.Fprintf(stdout, "  â””â”€â”€ logs/           Log files\n")
	fmt.Fprintf(stdout, "\n")
	fmt.Fprintf(stdout, "Get started:\n")
	fmt.Fprintf(stdout, "  cd %s\n", folderName)
	fmt.Fprintf(stdout, "  basil\n")
	fmt.Fprintf(stdout, "\n")
	fmt.Fprintf(stdout, "Your site will be running at http://localhost:8080\n")

	return nil
}
