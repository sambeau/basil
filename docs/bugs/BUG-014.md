# BUG-014: Module-level imports of @basil/http and @basil/auth are cached

**Status:** Fixed  
**Priority:** High  
**Reported:** 2026-01-05  
**Fixed:** 2026-01-05  
**Component:** Module Caching / Basil Context

## Symptom

When importing `@basil/http` or `@basil/auth` at module scope, the values are captured once and cached:

```parsley
// myhandler.pars
let {query} = import @basil/http      // ← Captured once, cached!
let {session} = import @basil/auth    // ← Captured once, cached!

fn handle() {
    // query and session are stale after first request
    <p>{query.name}</p>
}
```

Users must move imports inside function bodies as a workaround:

```parsley
fn handle() {
    let {query} = import @basil/http  // ← Fresh each call
    <p>{query.name}</p>
}
```

This is unintuitive—JavaScript and most other languages expect imports at module top.

## Expected Behavior

Module-level imports of `@basil/http` and `@basil/auth` should provide fresh values per-request, while still caching the module structure itself.

```parsley
// Should "just work" at module scope
let {query} = import @basil/http
let {session} = import @basil/auth

fn handle() {
    // query and session are fresh for THIS request
    <p>Hello {query.name}</p>
}
```

## Root Cause

1. User modules (`.pars` files) are cached in `moduleCache` after first evaluation
2. When `let {query} = import @basil/http` is evaluated, the current `env.BasilCtx` values are captured
3. On subsequent requests, the cached module is returned without re-evaluating the import
4. The captured `query` value is stale (from the first request)

## Proposed Solution: Dynamic Accessor Objects

Instead of returning concrete values from `@basil/http` and `@basil/auth`, return **dynamic accessor objects** that look up from the current environment when accessed.

### Design

1. Create a new `DynamicAccessor` object type:
```go
type DynamicAccessor struct {
    Name     string              // e.g., "query", "session"
    Resolver func(*Environment) Object
}
```

2. When property access or usage occurs, resolve to current value:
```go
// In evalIdentifier or property access
if accessor, ok := val.(*DynamicAccessor); ok {
    return accessor.Resolver(env)
}
```

3. Modify `loadBasilHTTPModule` and `loadBasilAuthModule` to return `DynamicAccessor` objects:
```go
func loadBasilHTTPModule(env *Environment) Object {
    return &StdlibModuleDict{
        Exports: map[string]Object{
            "query": &DynamicAccessor{
                Name: "query",
                Resolver: func(e *Environment) Object {
                    // Resolve from current environment's BasilCtx
                    basilDict := getBasilCtxDict(e)
                    httpObj := evalDictValue(basilDict, "http", e)
                    // ... extract query ...
                },
            },
            // ... etc
        },
    }
}
```

### Caching Layers

This naturally supports three caching layers:

1. **Configuration** (`@DB`, schemas): Cached in `env.ServerDB` — persists across requests
2. **Session** (`session`): Resolved from `env.BasilCtx.session` — per-session
3. **Request** (`query`, `route`, `method`): Resolved from `env.BasilCtx.http.request` — per-request

### Alternative Approaches Considered

**A. Don't cache modules that import @basil/***: Inefficient, re-parses on every request
**B. Per-request module cache**: Complex, requires passing request context to cache
**C. Documentation-only**: Current approach, unintuitive for developers

## Implementation Tasks

1. [x] Create `DynamicAccessor` object type in evaluator
2. [x] Handle `DynamicAccessor` resolution in identifier lookup and property access
3. [x] Modify `loadBasilHTTPModule` to return `DynamicAccessor` objects
4. [x] Modify `loadBasilAuthModule` to return `DynamicAccessor` objects
5. [x] Update destructuring to handle `DynamicAccessor` (bind accessor, not resolved value)
6. [x] Add tests for module-level imports across requests
7. [ ] Update documentation

## Fix Summary

**Root Cause:** When calling methods on dictionaries (e.g., `handler.getQuery()`), the function `applyMethodWithThis` was not propagating `BasilCtx` from the caller's environment to the extended function environment. This meant DynamicAccessor resolvers would find the cached closure's BasilCtx instead of the current request's BasilCtx.

**Fix:** Modified `applyMethodWithThis` to accept the calling environment and copy runtime context (including `BasilCtx`) to the extended function environment, matching the behavior of `ApplyFunctionWithEnv`.

**Files Changed:**
- `pkg/parsley/evaluator/stdlib_table.go`: Added DynamicAccessor type, updated @basil/http and @basil/auth loaders
- `pkg/parsley/evaluator/evaluator.go`: Updated applyMethodWithThis to propagate BasilCtx, added DynamicAccessor resolution in evalIdentifier and property access

**Test:** `TestDynamicAccessorInCachedModule` in `pkg/parsley/tests/module_cache_test.go`

## Test Cases

```parsley
// Test: Module-level query import works across requests
// handler.pars
let {query} = import @basil/http
export fn handle() { query.name }

// Request 1: ?name=Alice → "Alice"
// Request 2: ?name=Bob → "Bob" (not "Alice")
```

## Related

- FEAT-080: Module-level @DB support (introduced module caching)
- BUG-012: Module cache not invalidated on file change
