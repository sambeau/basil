---
id: record
title: Records
system: parsley
type: builtin
name: record
created: 2026-01-18
version: 0.16.0
author: Basil Team
keywords:
  - record
  - schema
  - validation
  - form
  - query
  - table
  - form-binding
  - html-forms
---

# Records

A **Record** is a schema-bound dictionary that carries its type information, validation state, and metadata. Records are the primary data structure for building HTML forms, processing user input, and working with database rows in Basil web applications.

**Key insight:** A Record = Schema + Data + Errors. Nothing more.

```parsley
@schema User {
    name: string(min: 2, required)
    email: email(required)
}

let user = User({name: "Alice", email: "alice@example.com"})
user.name           // "Alice" (data access)
user.isValid()      // false (not yet validated)

let validated = user.validate()
validated.isValid() // true
validated.errors()  // {}
```

---

## Why Records?

When building websites with database-driven content, you repeatedly face the same challenges:

1. **Validating user input** — checking required fields, formats, constraints
2. **Displaying validation errors** — showing users what went wrong
3. **Populating forms** — filling inputs with existing data or defaults
4. **Type safety** — ensuring form data matches your data model

Records solve all of these in a single, composable type. They flow naturally from database to form and back:

```
Database → Record → HTML Form → User edits → Record → Validation → Database
```

---

## Creating Records

### From a Schema

The primary way to create a Record is by calling a schema with a dictionary:

```parsley
@schema User {
    name: string(min: 2, required)
    email: email(required)
    age: int(min: 0)
}

// Dict → Record
let user = User({name: "Alice", email: "alice@example.com", age: 30})
```

### From Form Data

In a Basil handler, `props` contains form data as a dictionary. Pass it directly to your schema:

```parsley
export save = fn(props) {
    let form = User(props).validate()
    
    if (form.isValid()) {
        // Save to database
    } else {
        // Re-render form with errors
    }
}
```

### Using `.as()` for Chaining

The `.as(Schema)` method converts a dictionary to a Record, useful in pipelines:

```parsley
let user = fetchFromAPI().parse().as(User)
let row = csvRows[0].as(User)
```

### From Database Queries

Records returned from database queries are automatically validated:

```parsley
let Users = db.bind(User, "users")

// Single row → Record (auto-validated)
let user = @query(Users | id == {id} ?-> *)
user.isValid()   // true (data from DB is trusted)

// Multiple rows → Table of Records
let admins = @query(Users | role == "admin" ??-> *)
admins[0].name   // Access data directly
```

### When to Use Which

| Syntax | Best for |
|--------|----------|
| `Schema({...})` | Primary idiom, literal data, form processing |
| `Schema([...])` | Creating typed Tables from arrays |
| `{...}.as(Schema)` | Chaining, pipelines, API responses |
| Database queries | Rows come pre-validated |

---

## Schemas: Defining Your Data Shape

Schemas define the structure, types, constraints, and metadata for your data. They use the same syntax as the Query DSL.

### Basic Schema Definition

```parsley
@schema User {
    id: int(auto)                     // Database-generated
    name: string(min: 2, required)
    email: email(required)
    age: int(min: 0, max: 150)
    role: enum["user", "admin", "moderator"]
    website: url
    createdAt: datetime(auto)         // Server-generated timestamp
}
```

### Field Types

| Type | Description | HTML Input Type |
|------|-------------|-----------------|
| `string` | Text value | `text` |
| `text` | Long text | `textarea` |
| `int` | Integer number | `number` |
| `float`/`decimal` | Decimal number | `number` |
| `bool` | Boolean | `checkbox` |
| `email` | Email address | `email` |
| `url` | URL | `url` |
| `phone` | Phone number | `tel` |
| `date` | Date | `date` |
| `datetime` | Date and time | `datetime-local` |
| `time` | Time | `time` |
| `money` | Currency amount | `number` |
| `slug` | URL-safe string | `text` |
| `uuid`/`ulid` | Unique identifiers | `text` |
| `enum[...]` | Fixed set of values | `select` or `radio` |

### Constraints

| Constraint | Applies To | Example |
|------------|------------|---------|
| `required` | All types | `string(required)` |
| `min` | String length, numbers | `string(min: 2)`, `int(min: 0)` |
| `max` | String length, numbers | `string(max: 100)`, `int(max: 150)` |
| `pattern` | Strings | `string(pattern: "^[A-Z]+$")` |
| `default` | All types | `int(default: 1)` |
| `auto` | IDs, timestamps | `int(auto)` — skipped in validation |

### The `auto` Constraint

Fields marked `auto` are generated by the database (like auto-increment IDs or timestamps). They're skipped during validation and cannot be updated:

```parsley
@schema User {
    id: int(auto)                     // Can be omitted when creating
    createdAt: datetime(auto)         // Server sets this
    name: string(required)
}

let user = User({name: "Alice"})      // id and createdAt omitted
user.validate().isValid()             // true — auto fields skipped
user.update({id: 999})                // Error: cannot update auto field
```

---

## Metadata: Schema for Humans

Schemas can carry metadata for display, using the pipe (`|`) syntax to separate validation from presentation:

```parsley
@schema User {
    name: string(min: 2, required) | {title: "Full Name", placeholder: "Enter your name"}
    email: email(required) | {title: "Email Address", placeholder: "you@example.com"}
    age: int(min: 0) | {title: "Age", help: "Must be a positive number"}
    salary: decimal | {title: "Salary", format: "currency"}
    createdAt: datetime(auto) | {title: "Created", format: "date", hidden: true}
}
```

### Core Metadata Keys

| Key | Purpose | Used by |
|-----|---------|---------|
| `title` | Human-readable field name | Form labels, table headers |
| `placeholder` | Input placeholder text | Form inputs |
| `help` | Help text below field | Form hints |
| `format` | Display format | Value formatting |
| `hidden` | Exclude from default display | Auto-generated forms |

### Open Metadata

The metadata dictionary accepts **any** key-value pairs. Use this for custom features:

```parsley
@schema User {
    name: string(required) | {title: "Name", sortable: true, searchWeight: 2}
    avatar: string | {title: "Avatar", widget: "image-upload", maxSize: "5mb"}
}

// Access custom metadata
User.meta("name", "sortable")     // true
User.meta("avatar", "widget")     // "image-upload"
```

### Accessing Metadata from Records

Records provide shorthand methods to access schema metadata:

```parsley
let form = User({name: "Alice"})

// Shorthand (preferred)
form.title("name")              // "Full Name"
form.placeholder("email")       // "you@example.com"
form.meta("name", "help")       // "Your legal name"
form.enumValues("role")         // ["user", "admin", "moderator"]

// Long form (also works)
form.schema().title("name")
```

### Built-in Formats

The `format()` method formats values according to metadata hints:

```parsley
@schema Metrics {
    views: int | {format: "number"}
    revenue: decimal | {format: "currency"}
    conversionRate: float | {format: "percent"}
    createdAt: datetime | {format: "date"}
}

let m = Metrics({views: 1234567, revenue: 52000, conversionRate: 0.15})

m.format("views")           // "1,234,567"
m.format("revenue")         // "$52,000.00"
m.format("conversionRate")  // "15%"
m.format("createdAt")       // "Jan 15, 2025"
```

| Format | Example Input | Example Output |
|--------|---------------|----------------|
| `"number"` | `1234567` | "1,234,567" |
| `"currency"` | `52000` | "$52,000.00" |
| `"percent"` | `0.15` | "15%" |
| `"date"` | `2025-01-15` | "Jan 15, 2025" |
| `"datetime"` | `2025-01-15T14:30:00Z` | "Jan 15, 2025 2:30 PM" |

---

## Validation

### The Validation Flow

Records start **unvalidated**. Call `validate()` to check constraints:

```parsley
// Create record (no validation yet)
let record = User({name: "A", email: "bad"})
record.isValid()     // false (not validated)

// Validate
let validated = record.validate()
validated.isValid()  // false (has errors)
validated.errors()   // {name: {code: "MIN_LENGTH", ...}, email: {code: "FORMAT", ...}}
```

Validation checks in order:
1. **Required** — Is the field present and non-null?
2. **Type** — Does the value match the expected type?
3. **Format** — Does it match the format (email, URL, phone, etc.)?
4. **Length** — Does string length meet min/max?
5. **Value** — Do numbers meet min/max?
6. **Pattern** — Does it match the regex pattern?
7. **Enum** — Is the value in the allowed set?

### Error Codes

| Code | Meaning | Example Message |
|------|---------|-----------------|
| `REQUIRED` | Missing required field | "This field is required" |
| `TYPE` | Wrong data type | "Must be a number" |
| `FORMAT` | Invalid format | "Email is not a valid email address" |
| `ENUM` | Value not in allowed set | "Must be one of: user, admin" |
| `MIN_LENGTH` | String too short | "Must be at least 2 characters" |
| `MAX_LENGTH` | String too long | "Must be at most 100 characters" |
| `MIN_VALUE` | Number too small | "Must be at least 0" |
| `MAX_VALUE` | Number too large | "Must be at most 150" |
| `PATTERN` | Doesn't match regex | "Invalid format" |
| `CUSTOM` | Added via `withError()` | (Your message) |

### Accessing Errors

```parsley
let form = User({name: "A", email: "bad"}).validate()

// All errors as a dictionary
form.errors()           // {name: {code: "MIN_LENGTH", message: "..."}, 
                        //  email: {code: "FORMAT", message: "..."}}

// Single field
form.error("name")      // "Must be at least 2 characters"
form.errorCode("name")  // "MIN_LENGTH"
form.hasError("name")   // true

// As an array (useful for iteration)
form.errorList()        // [{field: "name", code: "MIN_LENGTH", message: "..."},
                        //  {field: "email", code: "FORMAT", message: "..."}]
```

### Custom Validation

For business rules and cross-field validation, use `withError()`:

```parsley
let form = User(props).validate()

// Cross-field validation
if (form.password != props.confirmPassword) {
    form = form.withError("confirmPassword", "MISMATCH", "Passwords don't match")
}

// Business rule validation
if (isEmailTaken(form.email)) {
    form = form.withError("email", "DUPLICATE", "Email already registered")
}
```

### Type Casting

Schema types drive automatic casting when creating records:

```parsley
@schema Settings {
    age: int
    active: bool
}

// Form data comes as strings
let record = Settings({age: "42", active: "true"})
record.age     // 42 (Integer, not "42" string)
record.active  // true (Boolean, not "true" string)
```

### Default Values

Defaults are applied on **creation**, not validation:

```parsley
@schema Request {
    page: int(default: 1)
    limit: int(default: 20)
    sort: string(default: "created_at")
}

let r = Request({})              // r.page = 1, r.limit = 20, r.sort = "created_at"
let r = Request({page: 5})       // r.page = 5, r.limit = 20, r.sort = "created_at"
let r = Request({page: null})    // r.page = 1 (null treated as missing)
```

### Field Filtering (Whitelisting)

Schema fields act as a whitelist. Unknown fields are silently ignored:

```parsley
@schema User {
    name: string
    email: email
}

// is_admin is silently dropped — not in schema
let record = User({name: "Alice", email: "a@b.com", is_admin: true})
record.data()  // {name: "Alice", email: "a@b.com"}
```

This provides security by default — malicious fields can't sneak through.

### `readOnly` Field Filtering

Fields marked `readOnly` in the schema are also filtered during record creation. This prevents clients from setting protected values, but has an important implication for delete operations:

```parsley
@schema Person {
    id: int(auto, readOnly)      // Protected from client input
    name: string
}

// Form submits {id: "123", name: "Alice"}
let person = Person(formData)
person.id                        // null (filtered!)

// This FAILS — id is null
People.delete(person)            // Error: no primary key value

// Solutions:
People.delete(formData.id)       // ✅ Pass ID directly
People.delete(params.id)         // ✅ Use URL parameter
let p = People.find(params.id)
People.delete(p)                 // ✅ Load from DB first
```

---

## Schema Checking

Use the `is` and `is not` operators to check whether a value is a Record bound to a specific schema. This is useful when working with mixed data or implementing type-safe dispatch.

### Basic Usage

```parsley
@schema User { name: string }
@schema Product { sku: string }

let user = User({name: "Alice"})

user is User                    // true
user is Product                 // false
user is not Product             // true
```

### Identity Comparison

Schema checking uses **pointer identity**, not structural matching. Two schemas with identical fields are still different schemas:

```parsley
@schema UserA { name: string }
@schema UserB { name: string }  // Same fields, different schema

let record = UserA({name: "Bob"})
record is UserA                 // true
record is UserB                 // false
```

### Filtering by Schema

A common use case is filtering mixed arrays by schema:

```parsley
@schema User { name: string }
@schema Product { sku: string }

let items = [
    User({name: "Alice"}),
    Product({sku: "A001"}),
    User({name: "Bob"})
]

// Get only users
let users = items.filter(fn(x) { x is User })
users.length()                  // 2

// Get non-users
let nonUsers = items.filter(fn(x) { x is not User })
nonUsers.length()               // 1
```

### Safe Type Checking

For non-record values (strings, numbers, plain dicts), `is` safely returns `false`:

```parsley
"hello" is User                 // false
42 is User                      // false
{name: "Alice"} is User         // false (plain dict, not a Record)
null is User                    // false
```

This makes `is` safe to use without prior type checking.

---

## Updating Records

Records are **immutable**. The `update()` method returns a new record with merged fields and **auto-revalidates**:

```parsley
let user = User({name: "Alice", email: "a@b.com"}).validate()
user.isValid()       // true

// Update returns new revalidated record
let updated = user.update({name: "A"})  // too short
updated.isValid()    // false (auto-revalidated)
updated.error("name") // "Must be at least 2 characters"

user.name            // "Alice" (original unchanged)
updated.name         // "A" (new record)
```

**Why auto-revalidate?** Like type-checking in a typed language — validation happens automatically so you can't forget. Update multiple fields at once for efficiency:

```parsley
// Efficient: validates once
let r = record.update({a: 1, b: 2, c: 3})
```

---

## Form Binding

Records shine brightest when building HTML forms. Basil provides special syntax to bind records to form elements, automatically handling values, validation attributes, and accessibility.

### Form Context

The `@record` attribute establishes form context:

```parsley
<form @record={form} method="POST">
    // Form elements can now use @field binding
</form>
```

The `@record` attribute itself is removed from the output — it's a compile-time directive.

### Input Binding with `@field`

The `@field` attribute binds an input to a schema field:

```parsley
<form @record={form} method="POST">
    <input @field="name"/>
    <input @field="email"/>
</form>
```

**What `@field` does:**

1. **Sets `name` attribute** — for form submission
2. **Sets `value` attribute** — from record data
3. **Sets `type` attribute** — derived from schema type
4. **Adds constraint attributes** — `required`, `minlength`, `maxlength`, `min`, `max`, `pattern`
5. **Adds accessibility attributes** — `aria-invalid`, `aria-describedby`, `aria-required`

This single input:

```parsley
<input @field="email"/>
```

Expands to:

```html
<input name="email" 
       value="alice@example.com" 
       type="email"
       required
       aria-invalid="false"
       aria-describedby="email-error"
       aria-required="true"/>
```

### Type Derivation

Form inputs automatically derive their `type` from the schema:

| Schema Type | HTML Input Type |
|-------------|-----------------|
| `email` | `type="email"` |
| `url` | `type="url"` |
| `phone` | `type="tel"` |
| `int`, `float` | `type="number"` |
| `date` | `type="date"` |
| `datetime` | `type="datetime-local"` |
| `time` | `type="time"` |
| `bool` | `type="checkbox"` |

Override with an explicit type attribute if needed:

```parsley
<input @field="phone" type="text"/>  // Uses text instead of tel
```

### Checkbox and Radio Binding

**Checkboxes** bind to boolean fields:

```parsley
<input @field="active" type="checkbox"/>
// Renders with checked={form.active}
```

**Radio buttons** check against a specific value:

```parsley
<input @field="role" type="radio" value="admin"/>
<input @field="role" type="radio" value="user"/>
// First is checked if form.role == "admin"
```

### The `<Label>` Component

`<Label>` renders a label with the field's title from metadata:

```parsley
// Self-closing form (generates for attribute)
<Label @field="email"/>
// Renders: <label for="email">Email Address</label>

// With children (wraps content)
<Label @field="name">" (required)"</Label>
// Renders: <label for="name">Full Name (required)</label>
```

If no `title` metadata exists, the field name is title-cased automatically:
- `firstName` → "First Name"
- `email` → "Email"

Use `@tag` to change the element type:

```parsley
<Label @field="email" @tag="span"/>
// Renders: <span>Email Address</span>
```

### The `<Error>` Component

`<Error>` conditionally renders validation errors:

```parsley
<Error @field="email"/>
// When error exists: <span id="email-error" class="error" role="alert">Invalid email</span>
// When no error: (nothing rendered)
```

The `id` matches `aria-describedby` on the input, connecting them for screen readers. The `role="alert"` announces errors when they appear.

Use `@tag` to change the element:

```parsley
<Error @field="email" @tag="div"/>
<Error @field="email" @tag="small"/>
```

### The `<Meta>` Component

`<Meta>` renders any metadata value:

```parsley
<Meta @field="email" @key="help"/>
// Renders: <span>We'll never share your email</span>
// Or nothing if key doesn't exist
```

Use for help text, hints, or custom metadata:

```parsley
<Meta @field="email" @key="help" @tag="small"/>
// Renders: <small>We'll never share your email</small>
```

### The `<Select>` Component

`<Select>` auto-generates options for enum fields:

```parsley
@schema User {
    status: enum["active", "pending", "inactive"]
}

<Select @field="status"/>
```

Renders:

```html
<select name="status" required aria-required="true" aria-invalid="false">
    <option value="">Select status</option>
    <option value="active">active</option>
    <option value="pending" selected>pending</option>
    <option value="inactive">inactive</option>
</select>
```

Custom placeholder:

```parsley
<Select @field="status" placeholder="Choose a status..."/>
```

For complex cases (optgroups, custom labels), build manually:

```parsley
<select @field="status">
    <option value="">{form.placeholder("status")}</option>
    for (val in form.enumValues("status")) {
        <option value={val} selected={form.status == val}>{val}</option>
    }
</select>
```

### Accessibility Attributes

Form binding automatically adds ARIA attributes for screen readers:

| Attribute | Value | Purpose |
|-----------|-------|---------|
| `aria-invalid` | `"true"`/`"false"` | Indicates validation state |
| `aria-describedby` | `"{field}-error"` | Links input to error message |
| `aria-required` | `"true"` | Mirrors HTML `required` |

**Note:** `aria-invalid="false"` is explicitly set (not omitted) so CSS selectors like `[aria-invalid="true"]` and `[aria-invalid="false"]` can style valid/invalid states.

### Complete Form Example

Here's a complete form with validation:

```parsley
@schema User {
    name: string(min: 2, required) | {title: "Full Name", help: "Your legal name"}
    email: email(required) | {title: "Email", help: "We'll never share this"}
    role: enum["user", "admin"] | {title: "Role"}
}

export default = fn(props) {
    let form = props.form ?? User({})
    
    <form @record={form} method="POST" action="save">
        <div class="field">
            <Label @field="name"/>
            <input @field="name"/>
            <Error @field="name"/>
            <Meta @field="name" @key="help" @tag="small"/>
        </div>
        
        <div class="field">
            <Label @field="email"/>
            <input @field="email"/>
            <Error @field="email"/>
            <Meta @field="email" @key="help" @tag="small"/>
        </div>
        
        <div class="field">
            <Label @field="role"/>
            <Select @field="role"/>
            <Error @field="role"/>
        </div>
        
        <button type="submit">"Save"</button>
    </form>
}

export save = fn(props) {
    let form = User(props).validate()
    
    if (form.isValid()) {
        @insert(Users |< ...form .)
        <div class="success">"User saved successfully!"</div>
    } else {
        default({form: form})
    }
}
```

---

## Data and Serialization

### Extracting Data

```parsley
let user = User({name: "Alice", email: "alice@example.com"})

user.data()           // {name: "Alice", email: "alice@example.com"}
user.keys()           // ["name", "email"] (declaration order)
user.toJSON()         // '{"name":"Alice","email":"alice@example.com"}'
```

### Direct Property Access

Access data fields directly on the record:

```parsley
user.name             // "Alice"
user.email            // "alice@example.com"
user.unknownField     // null
```

### Dictionary Compatibility

Records work where dictionaries are expected:

```parsley
let user = User({name: "Alice"})

// Spread into dictionary
let merged = {...user, extraField: "value"}

// JSON encoding
json.encode(user)     // Encodes data fields only

// Pass to function expecting dictionary
someFunc(user)        // Works
```

---

## Integration with Tables and Databases

### Creating Typed Tables

Pass an array to a schema to create a typed table:

```parsley
let users = User([
    {name: "Alice", email: "alice@example.com"},
    {name: "Bob", email: "bob@example.com"}
])

// Or use table() with .as()
let users = table(csvData).as(User)
```

### Table Validation

Tables support bulk validation:

```parsley
let validated = users.validate()

validated.isValid()      // true if ALL rows valid
validated.errors()       // [{row: 0, field: "email", code: "FORMAT", message: "..."}]
validated.validRows()    // Table of valid rows only
validated.invalidRows()  // Table of invalid rows with errors

// Individual rows are Records
validated[0].errors()    // {email: {code: "FORMAT", message: "..."}}
```

### Database Queries Return Records

When a table is bound to a schema, queries return Records:

```parsley
let db = @sqlite("app.db")
let Users = db.bind(User, "users")

// Single row → Record
let user = @query(Users | id == {id} ?-> *)
user.name           // Data access
user.isValid()      // true (auto-validated from DB)
user.title("name")  // "Full Name" (metadata access)

// Multiple rows → Table of Records  
let admins = @query(Users | role == "admin" ??-> *)
```

### Records vs Tables

| Type | Created By | Use Case |
|------|------------|----------|
| **Record** | `Schema({...})` or `{...}.as(Schema)` | Single entity: form, API request, one DB row |
| **Table** | `Schema([...])` or `table(data).as(Schema)` | Multiple entities: CSV, query results, lists |

**For form validation:** Use Records.  
**For bulk import/pipelines:** Use Tables with `.validate()`.

---

## Method Reference

### Validation Methods

| Method | Returns | Description |
|--------|---------|-------------|
| `validate()` | Record | Validate and return with errors populated |
| `isValid()` | Boolean | True if validated AND no errors |
| `errors()` | Dictionary | All errors: `{field: {code, message}}` |
| `error(field)` | String or null | Error message for field |
| `errorCode(field)` | String or null | Error code for field |
| `errorList()` | Array | Errors as: `[{field, code, message}]` |
| `hasError(field)` | Boolean | True if field has error |
| `withError(field, msg)` | Record | Add custom error |
| `withError(field, code, msg)` | Record | Add custom error with code |

### Metadata Methods

| Method | Returns | Description |
|--------|---------|-------------|
| `title(field)` | String | Title from metadata or title-cased name |
| `placeholder(field)` | String or null | Placeholder from metadata |
| `meta(field, key)` | Any or null | Any metadata value |
| `enumValues(field)` | Array | Enum options or empty array |
| `format(field)` | String | Formatted value using metadata hint |

### Data Methods

| Method | Returns | Description |
|--------|---------|-------------|
| `data()` | Dictionary | Plain dict of all data |
| `keys()` | Array | Field names in declaration order |
| `schema()` | Schema or null | The bound schema |
| `toJSON()` | String | JSON encoding of data |

### Update Methods

| Method | Returns | Description |
|--------|---------|-------------|
| `update(dict)` | Record | Merge fields and auto-revalidate |

---

## Quick Reference

```parsley
// Define schema with metadata
@schema User {
    name: string(min: 2, required) | {title: "Full Name"}
    email: email(required) | {title: "Email"}
    role: enum["user", "admin"] | {title: "Role"}
}

// Create record
let form = User({name: "Alice", email: "alice@example.com"})

// Validate
let validated = form.validate()
validated.isValid()         // true/false
validated.error("name")     // Error message or null

// Build form
<form @record={validated} method="POST">
    <Label @field="name"/>
    <input @field="name"/>
    <Error @field="name"/>
    
    <Label @field="email"/>
    <input @field="email"/>
    <Error @field="email"/>
    
    <Label @field="role"/>
    <Select @field="role"/>
    <Error @field="role"/>
    
    <button type="submit">"Save"</button>
</form>
```
