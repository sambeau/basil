# Basil Quick Start

Get a Parsley-powered web app running in 5 minutes.

## Prerequisites

- Go 1.21+ installed
- Parsley library available (via replace directive or published)

## Installation

```bash
# Clone and build
git clone https://github.com/sambeau/basil.git
cd basil
go build -o basil .
```

## Your First Basil App

### 1. Create Project Structure

```
myapp/
â”œâ”€â”€ basil.yaml           # Configuration
â”œâ”€â”€ handlers/
â”‚   â””â”€â”€ index.pars       # Homepage handler
â””â”€â”€ public/
    â””â”€â”€ style.css        # Static files
```

### 2. Create Configuration

**basil.yaml:**
```yaml
server:
  host: localhost
  port: 8080

static:
  - path: /static/
    root: ./public

routes:
  - path: /
    handler: ./handlers/index.pars
```

### 3. Create a Handler

**handlers/index.pars:**
```parsley
// Homepage handler
let title = "My Basil App"

<html>
<head>
  <title>{title}</title>
  <link rel="stylesheet" href="/static/style.css"/>
</head>
<body>
  <h1>Welcome to {title}!</h1>
  <p>This page was generated by Parsley.</p>
</body>
</html>
```

### 4. Add Some Style

**public/style.css:**
```css
body {
  font-family: system-ui, sans-serif;
  max-width: 800px;
  margin: 2rem auto;
  padding: 0 1rem;
}
h1 { color: #2d5016; }
```

### 5. Run It!

```bash
# From your project directory
basil --dev --config basil.yaml
```

Visit http://localhost:8080 ðŸŽ‰

## Key Concepts

### Dev Mode
Use `--dev` for local development:
- Runs HTTP on localhost (no HTTPS required)
- Disables script caching (edit and refresh!)
- Port defaults to 8080

### Configuration
Basil finds config in this order:
1. `--config` flag
2. `BASIL_CONFIG` environment variable
3. `./basil.yaml` in current directory
4. `~/.config/basil/basil.yaml`

### ENV Variables
Config supports `${VAR:-default}` syntax:
```yaml
server:
  port: ${PORT:-8080}
```

### Routes
Routes map URL paths to Parsley handlers:
```yaml
routes:
  - path: /              # Exact match
    handler: ./handlers/index.pars
  - path: /api/hello
    handler: ./handlers/api/hello.pars
```

### Static Files
Serve directories or single files:
```yaml
static:
  - path: /static/       # Directory
    root: ./public
  - path: /favicon.ico   # Single file
    file: ./public/favicon.ico
```

### Logging
Configure request logging:
```yaml
logging:
  level: info        # debug, info, warn, error
  format: text       # text or json
  output: stdout     # stdout, stderr, or file path
```

**Text format** (default):
```
2025-11-30T12:34:56Z GET /api/hello 200 1.234ms
```

**JSON format** (for log aggregators):
```json
{"timestamp":"2025-11-30T12:34:56Z","method":"GET","path":"/api/hello","status":200,"duration":"1.234ms","duration_ms":1,"client_ip":"127.0.0.1:52345","user_agent":"curl/8.0"}
```

### Request Data

Your Parsley handlers receive request data via the `basil` namespace object:

**Accessing request data:**
```parsley
basil.http.request = {
  method:     "GET",
  path:       "/api/hello",
  query:      {name: "world"},
  headers:    {"Content-Type": "application/json", "User-Agent": "..."},
  host:       "localhost:8080",
  remoteAddr: "127.0.0.1:52345",
  body:       "...", // raw request body (POST/PUT/PATCH only)
  form:       {},    // parsed form data or JSON body
  files:      {}     // uploaded file metadata (multipart only)
}
```

**Example: Using request data:**
```parsley
let req = basil.http.request
let name = req.query.name ?? "stranger"
let userAgent = req.headers["User-Agent"] ?? "unknown"

<html>
<body>
  <h1>Hello, {name}!</h1>
  <p>You're using: {userAgent}</p>
  <p>Your IP: {req.remoteAddr}</p>
</body>
</html>
```

### Response Types

**HTML** (auto-detected by leading `<`):
```parsley
`<html><body>Hello!</body></html>`
```

**JSON** (return a map/dictionary):
```parsley
{
  message: "Hello!",
  timestamp: now()
}
```

**Custom Response** (set metadata via `basil.http.response`):
```parsley
// Set response metadata
basil.http.response.status = 201
basil.http.response.headers["X-Custom"] = "value"

// Return the body (your return value is the body)
`<p>Created!</p>`
```

### Handling Forms

**URL-encoded forms** (`application/x-www-form-urlencoded`):
```parsley
let req = basil.http.request

// Form data is in basil.http.request.form
let username = req.form.username ?? ""
let email = req.form.email ?? ""

if req.method == "POST" {
  // Process form submission
  `<p>Thanks, {username}!</p>`
} else {
  `<form method="POST">
    <input name="username" placeholder="Username"/>
    <input name="email" type="email" placeholder="Email"/>
    <button>Submit</button>
  </form>`
}
```

**JSON API requests** (`application/json`):
```parsley
// JSON body is parsed into basil.http.request.form
let data = basil.http.request.form
{
  received: data,
  message: "Got your JSON!"
}
```

**File uploads** (`multipart/form-data`):
```parsley
// File metadata is in basil.http.request.files
let file = basil.http.request.files.document
if file {
  `<p>Uploaded: {file.filename} ({file.size} bytes)</p>`
}
```

## Using Modules

Create reusable components:

**handlers/Page.pars:**
```parsley
export Page = fn({title, contents}) {
  `<html>
  <head><title>{title}</title></head>
  <body>{contents}</body>
  </html>`
}
```

**handlers/index.pars:**
```parsley
{Page} = import(@./Page.pars)

<Page title="Home">
  <h1>Welcome!</h1>
</Page>
```

### Handler Root Imports (@~/)

Use `@~/` to import relative to the handler's directory instead of the current file. This eliminates `../../../` navigation in deeply nested files:

```
handlers/
â”œâ”€â”€ index.pars          # handler root
â”œâ”€â”€ components/
â”‚   â””â”€â”€ page.pars
â””â”€â”€ utils/
    â””â”€â”€ deep/
        â””â”€â”€ nested.pars
```

**handlers/utils/deep/nested.pars:**
```parsley
// Instead of: import(@../../components/page.pars)
{Page} = import(@~/components/page.pars)
```

## Database Support

Basil integrates with SQLite databases using Parsley's database operators.

### Configuration

**basil.yaml:**
```yaml
database:
  driver: sqlite
  path: ./data.db    # Relative to config file
```

### Using the Database

In your handlers, the database connection is available as `basil.sqlite`:

**handlers/users.pars:**
```parsley
// Query all users
let users = basil.sqlite <=??=> "SELECT * FROM users ORDER BY name"

<html>
<body>
  <h1>Users</h1>
  <ul>
  {for (user in users) {
    <li>{user.name} ({user.email})</li>
  }}
  </ul>
</body>
</html>
```

### Database Operators

| Operator | Description | Returns |
|----------|-------------|---------|
| `<=?=>` | Query single row | Dictionary or `null` |
| `<=??=>` | Query multiple rows | Array of dictionaries |
| `<=!=>` | Execute mutation | `{affected, lastId}` |

### Examples

**Query single row:**
```parsley
let user = basil.sqlite <=?=> "SELECT * FROM users WHERE id = 1"
if user {
  <p>Found: {user.name}</p>
} else {
  <p>User not found</p>
}
```

**Insert data:**
```parsley
let result = basil.sqlite <=!=> "INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com')"
<p>Created user with ID: {result.lastId}</p>
```

**Update data:**
```parsley
let result = basil.sqlite <=!=> "UPDATE users SET name = 'Bob' WHERE id = 1"
<p>Updated {result.affected} row(s)</p>
```

### Database Setup

Create your tables before running Basil. You can use the SQLite CLI:

```bash
sqlite3 data.db <<EOF
CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  email TEXT UNIQUE
);
INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');
EOF
```

Or create a setup handler:

**handlers/setup.pars:**
```parsley
let _ = basil.sqlite <=!=> "CREATE TABLE IF NOT EXISTS users (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  email TEXT UNIQUE
)"
<p>Database initialized!</p>
```

### Notes

- Basil manages the database connection lifecycle
- The connection uses WAL mode for better concurrency
- SQLite is limited to one writer at a time
- Parsley scripts cannot close the managed connection

## Security

Basil includes security features for production deployments.

### HTTPS/TLS

Basil supports three HTTPS modes depending on your environment:

#### Development (localhost)

Use `--dev` flag. HTTPS is not required and validation is skipped:

```yaml
server:
  host: localhost
  port: 8080
```

```bash
basil --dev
```

#### Local HTTPS Testing (self-signed certificates)

For testing HTTPS locally without Let's Encrypt:

```bash
# Generate self-signed cert for localhost
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem \
  -days 365 -nodes -subj "/CN=localhost"
```

```yaml
server:
  host: localhost
  port: 443
https:
  cert: ./cert.pem
  key: ./key.pem
```

**Note:** Browsers will show a security warning for self-signed certs.

#### Production (Let's Encrypt)

For production with automatic Let's Encrypt certificates:

```yaml
server:
  host: example.com     # Must be a real domain pointing to your server
  port: 443
https:
  auto: true
  email: admin@example.com    # Required for Let's Encrypt notifications
  cache_dir: ./certs          # Where to store certificates (default: "certs")
```

**Requirements for Let's Encrypt:**
- A publicly accessible hostname (not localhost)
- Port 80 open for ACME HTTP-01 challenges
- Port 443 for HTTPS traffic
- DNS pointing to your server

**How it works:**
- Basil listens on port 443 for HTTPS
- An HTTP server on port 80 handles ACME challenges and redirects to HTTPS
- Certificates are automatically renewed before expiry
- HTTP/2 is enabled by default

### Security Headers

Basil sets secure defaults for all responses:

| Header | Default | Purpose |
|--------|---------|---------|
| `Strict-Transport-Security` | 1 year, includeSubDomains | Force HTTPS |
| `X-Content-Type-Options` | nosniff | Prevent MIME-sniffing |
| `X-Frame-Options` | DENY | Prevent clickjacking |
| `X-XSS-Protection` | 1; mode=block | Legacy XSS filter |
| `Referrer-Policy` | strict-origin-when-cross-origin | Control referrer info |

**Customizing headers:**
```yaml
security:
  hsts:
    enabled: true
    max_age: "63072000"        # 2 years
    include_subdomains: true
    preload: true              # For HSTS preload list
  content_type_options: nosniff
  frame_options: SAMEORIGIN    # Allow same-origin framing
  xss_protection: "1; mode=block"
  referrer_policy: no-referrer
  csp: "default-src 'self'; script-src 'self'"
  permissions_policy: "geolocation=(), microphone=()"
```

**Dev mode note:** HSTS headers are not sent in dev mode to avoid browser issues.

### Reverse Proxy Support

When running behind a load balancer or reverse proxy (nginx, Cloudflare, etc.):

```yaml
server:
  proxy:
    trusted: true              # Trust X-Forwarded-* headers
    trusted_ips:               # Optional: only trust specific proxies
      - 10.0.0.1
      - 10.0.0.2
```

**What this enables:**
- Client IP extracted from `X-Forwarded-For` or `X-Real-IP`
- Original client IP used in request logging
- Available in handlers via `basil.http.request.remoteAddr`

**Security note:** Only enable `proxy.trusted` when actually behind a proxy. Untrusted clients could spoof headers otherwise.

## Response Caching

Basil can cache generated responses per-route for improved performance.

### Configuration

Enable caching with a TTL (time-to-live) on specific routes:

```yaml
routes:
  - path: /
    handler: ./handlers/index.pars
    cache: 5m                    # Cache for 5 minutes

  - path: /api/data
    handler: ./handlers/api/data.pars
    cache: 30s                   # Cache for 30 seconds

  - path: /admin/
    handler: ./handlers/admin.pars
    # No cache - always fresh (good for admin pages)
```

**Supported duration formats:**
- `30s` â€” 30 seconds
- `5m` â€” 5 minutes
- `1h` â€” 1 hour
- `24h` â€” 24 hours

### How It Works

- Only GET requests are cached
- Cache key includes method, path, and query string
- Only successful responses (2xx) are cached
- `X-Cache: HIT` or `X-Cache: MISS` header indicates cache status
- Cache is disabled in dev mode

### Cache Management

**Reload scripts and clear cache:**
```bash
kill -HUP $(pgrep basil)
```

This clears both the AST cache (compiled scripts) and response cache without restarting the server.

### When to Use Caching

**Good candidates:**
- Homepage and landing pages
- API endpoints with stable data
- Documentation pages
- RSS feeds

**Avoid caching:**
- Pages with user-specific content
- Real-time data
- Admin interfaces
- POST/PUT/DELETE endpoints (automatically excluded)

## CLI Reference

```
basil                       # Use default config resolution
basil --config app.yaml     # Explicit config file
basil --dev                 # Development mode (HTTP, no caching)
basil --dev --port 3000     # Custom port
basil --version             # Show version
basil --help                # Show help
```

## Next Steps

- See `examples/hello/` for a complete example
- Read [FEAT-002 spec](../specs/FEAT-002.md) for full details
- Check [FAQ](faq.md) for common questions
