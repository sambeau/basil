# Basil Quick Start

Get a Parsley-powered web app running in 5 minutes.

## Prerequisites

- Go 1.21+ installed
- Parsley library available (via replace directive or published)

## Installation

```bash
# Clone and build
git clone https://github.com/sambeau/basil.git
cd basil
go build -o basil .
```

## Your First Basil App

### 1. Create Project Structure

```
myapp/
â”œâ”€â”€ basil.yaml           # Configuration
â”œâ”€â”€ handlers/
â”‚   â””â”€â”€ index.pars       # Homepage handler
â””â”€â”€ public/
    â””â”€â”€ style.css        # Static files
```

### 2. Create Configuration

**basil.yaml:**
```yaml
server:
  host: localhost
  port: 8080

static:
  - path: /static/
    root: ./public

routes:
  - path: /
    handler: ./handlers/index.pars
```

### 3. Create a Handler

**handlers/index.pars:**
```parsley
// Homepage handler
let title = "My Basil App"

<html>
<head>
  <title>{title}</title>
  <link rel="stylesheet" href="/static/style.css"/>
</head>
<body>
  <h1>Welcome to {title}!</h1>
  <p>This page was generated by Parsley.</p>
</body>
</html>
```

### 4. Add Some Style

**public/style.css:**
```css
body {
  font-family: system-ui, sans-serif;
  max-width: 800px;
  margin: 2rem auto;
  padding: 0 1rem;
}
h1 { color: #2d5016; }
```

### 5. Run It!

```bash
# From your project directory
basil --dev --config basil.yaml
```

Visit http://localhost:8080 ðŸŽ‰

## Key Concepts

### Dev Mode
Use `--dev` for local development:
- Runs HTTP on localhost (no HTTPS required)
- Disables script caching (edit and refresh!)
- Port defaults to 8080

### Configuration
Basil finds config in this order:
1. `--config` flag
2. `BASIL_CONFIG` environment variable
3. `./basil.yaml` in current directory
4. `~/.config/basil/basil.yaml`

### ENV Variables
Config supports `${VAR:-default}` syntax:
```yaml
server:
  port: ${PORT:-8080}
```

### Routes
Routes map URL paths to Parsley handlers:
```yaml
routes:
  - path: /              # Exact match
    handler: ./handlers/index.pars
  - path: /api/hello
    handler: ./handlers/api/hello.pars
```

### Static Files
Serve directories or single files:
```yaml
static:
  - path: /static/       # Directory
    root: ./public
  - path: /favicon.ico   # Single file
    file: ./public/favicon.ico
```

### Logging
Configure request logging:
```yaml
logging:
  level: info        # debug, info, warn, error
  format: text       # text or json
  output: stdout     # stdout, stderr, or file path
```

**Text format** (default):
```
2025-11-30T12:34:56Z GET /api/hello 200 1.234ms
```

**JSON format** (for log aggregators):
```json
{"timestamp":"2025-11-30T12:34:56Z","method":"GET","path":"/api/hello","status":200,"duration":"1.234ms","duration_ms":1,"client_ip":"127.0.0.1:52345","user_agent":"curl/8.0"}
```

### Request Data
Your Parsley handlers receive request data via convenient variables:

**Quick access variables:**
```parsley
method   // "GET", "POST", etc.
path     // "/api/hello"
query    // {name: "world"} from ?name=world
```

**Full request object:**
```parsley
request = {
  method:     "GET",
  path:       "/api/hello",
  query:      {name: "world"},
  headers:    {"Content-Type": "application/json", "User-Agent": "..."},
  host:       "localhost:8080",
  remoteAddr: "127.0.0.1:52345",
  auth:       "",    // route's auth setting: "required", "optional", or ""
  body:       "...", // raw request body (POST/PUT/PATCH only)
  form:       {},    // parsed form data or JSON body
  files:      {}     // uploaded file metadata (multipart only)
}
```

**Example: Using request data:**
```parsley
let name = query.name ?? "stranger"
let userAgent = request.headers["User-Agent"] ?? "unknown"

<html>
<body>
  <h1>Hello, {name}!</h1>
  <p>You're using: {userAgent}</p>
  <p>Your IP: {request.remoteAddr}</p>
</body>
</html>
```

### Response Types

**HTML** (auto-detected by leading `<`):
```parsley
`<html><body>Hello!</body></html>`
```

**JSON** (return a map/dictionary):
```parsley
{
  message: "Hello!",
  timestamp: now()
}
```

**Custom Response** (full control):
```parsley
{
  status: 201,
  headers: {"X-Custom": "value"},
  body: "Created!"
}
```

### Handling Forms

**URL-encoded forms** (`application/x-www-form-urlencoded`):
```parsley
// Form data is in request.form
let username = request.form.username ?? ""
let email = request.form.email ?? ""

if method == "POST" {
  // Process form submission
  `<p>Thanks, {username}!</p>`
} else {
  `<form method="POST">
    <input name="username" placeholder="Username"/>
    <input name="email" type="email" placeholder="Email"/>
    <button>Submit</button>
  </form>`
}
```

**JSON API requests** (`application/json`):
```parsley
// JSON body is parsed into request.form
let data = request.form
{
  received: data,
  message: "Got your JSON!"
}
```

**File uploads** (`multipart/form-data`):
```parsley
// File metadata is in request.files
let file = request.files.document
if file {
  `<p>Uploaded: {file.filename} ({file.size} bytes)</p>`
}
```

## Using Modules

Create reusable components:

**handlers/Page.pars:**
```parsley
export Page = fn({title, contents}) {
  `<html>
  <head><title>{title}</title></head>
  <body>{contents}</body>
  </html>`
}
```

**handlers/index.pars:**
```parsley
{Page} = import(@./Page.pars)

<Page title="Home">
  <h1>Welcome!</h1>
</Page>
```

## Database Support

Basil integrates with SQLite databases using Parsley's database operators.

### Configuration

**basil.yaml:**
```yaml
database:
  driver: sqlite
  path: ./data.db    # Relative to config file
```

### Using the Database

In your handlers, the database connection is available as `db`:

**handlers/users.pars:**
```parsley
// Query all users
let users = db <=??=> "SELECT * FROM users ORDER BY name"

<html>
<body>
  <h1>Users</h1>
  <ul>
  {for (user in users) {
    <li>{user.name} ({user.email})</li>
  }}
  </ul>
</body>
</html>
```

### Database Operators

| Operator | Description | Returns |
|----------|-------------|---------|
| `<=?=>` | Query single row | Dictionary or `null` |
| `<=??=>` | Query multiple rows | Array of dictionaries |
| `<=!=>` | Execute mutation | `{affected, lastId}` |

### Examples

**Query single row:**
```parsley
let user = db <=?=> "SELECT * FROM users WHERE id = 1"
if user {
  <p>Found: {user.name}</p>
} else {
  <p>User not found</p>
}
```

**Insert data:**
```parsley
let result = db <=!=> "INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com')"
<p>Created user with ID: {result.lastId}</p>
```

**Update data:**
```parsley
let result = db <=!=> "UPDATE users SET name = 'Bob' WHERE id = 1"
<p>Updated {result.affected} row(s)</p>
```

### Database Setup

Create your tables before running Basil. You can use the SQLite CLI:

```bash
sqlite3 data.db <<EOF
CREATE TABLE users (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  email TEXT UNIQUE
);
INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com');
EOF
```

Or create a setup handler:

**handlers/setup.pars:**
```parsley
let _ = db <=!=> "CREATE TABLE IF NOT EXISTS users (
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  email TEXT UNIQUE
)"
<p>Database initialized!</p>
```

### Notes

- Basil manages the database connection lifecycle
- The connection uses WAL mode for better concurrency
- SQLite is limited to one writer at a time
- Parsley scripts cannot close the managed connection

## CLI Reference

```
basil                       # Use default config resolution
basil --config app.yaml     # Explicit config file
basil --dev                 # Development mode (HTTP, no caching)
basil --dev --port 3000     # Custom port
basil --version             # Show version
basil --help                # Show help
```

## Next Steps

- See `examples/hello/` for a complete example
- Read [FEAT-002 spec](../specs/FEAT-002.md) for full details
- Check [FAQ](faq.md) for common questions
