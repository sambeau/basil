==================
Let statement — simple
==================

let x = 5

---

(source_file
  (let_statement
    pattern: (identifier)
    value: (number)))

==================
Let statement — string value
==================

let name = "Alice"

---

(source_file
  (let_statement
    pattern: (identifier)
    value: (string)))

==================
Let statement — array destructuring
==================

let [a, b, c] = arr

---

(source_file
  (let_statement
    pattern: (array_pattern
      (identifier)
      (identifier)
      (identifier))
    value: (identifier)))

==================
Let statement — array destructuring with rest
==================

let [first, ...rest] = arr

---

(source_file
  (let_statement
    pattern: (array_pattern
      (identifier)
      (identifier))
    value: (identifier)))

==================
Let statement — dict destructuring
==================

let {name, age} = person

---

(source_file
  (let_statement
    pattern: (dictionary_pattern
      (identifier)
      (identifier))
    value: (identifier)))

==================
Let statement — dict destructuring with rest
==================

let {a, ...rest} = dict

---

(source_file
  (let_statement
    pattern: (dictionary_pattern
      (identifier)
      (identifier))
    value: (identifier)))

==================
Let statement — read from file
==================

let data <== @./file.txt

---

(source_file
  (let_statement
    pattern: (identifier)
    value: (path_literal)))

==================
Let statement — fetch from URL
==================

let data <=/= @https://api.example.com

---

(source_file
  (let_statement
    pattern: (identifier)
    value: (url_literal)))

==================
Let statement — dict destructuring with read
==================

let {a, b} <== @./data.json

---

(source_file
  (let_statement
    pattern: (dictionary_pattern
      (identifier)
      (identifier))
    value: (path_literal)))

==================
Assignment statement — simple
==================

x = 5

---

(source_file
  (assignment_statement
    left: (identifier)
    right: (number)))

==================
Assignment statement — member target
==================

obj.name = "Alice"

---

(source_file
  (assignment_statement
    left: (member_expression
      object: (identifier)
      property: (identifier))
    right: (string)))

==================
Assignment statement — index target
==================

arr[0] = 99

---

(source_file
  (assignment_statement
    left: (index_expression
      object: (identifier)
      index: (number))
    right: (number)))

==================
Assignment statement — read from file
==================

data <== @./file.txt

---

(source_file
  (assignment_statement
    left: (identifier)
    right: (path_literal)))

==================
Dict destructuring assignment
==================

{a, b} = expr

---

(source_file
  (dict_destructuring_assignment
    pattern: (dictionary_pattern
      (identifier)
      (identifier))
    value: (identifier)))

==================
Export statement — simple assignment
==================

export greeting = "Hello"

---

(source_file
  (export_statement
    name: (identifier)
    value: (string)))

==================
Export statement — computed with expression
==================

export computed total = a + b

---

(source_file
  (export_statement
    name: (identifier)
    value: (infix_expression
      left: (identifier)
      right: (identifier))))

==================
Export statement — computed with block
==================

export computed total {
  a + b
}

---

(source_file
  (export_statement
    name: (identifier)
    value: (block
      (expression_statement
        (infix_expression
          left: (identifier)
          right: (identifier))))))

==================
Export statement — with let
==================

export let x = 5

---

(source_file
  (export_statement
    pattern: (identifier)
    value: (number)))

==================
Export statement — bare export
==================

export greeting

---

(source_file
  (export_statement
    name: (identifier)))

==================
Return statement — with value
==================

return x + 1

---

(source_file
  (return_statement
    value: (infix_expression
      left: (identifier)
      right: (number))))

==================
Return statement — bare return
==================

return

---

(source_file
  (return_statement))

==================
Check statement — with else
==================

check x > 0 else "negative"

---

(source_file
  (check_statement
    condition: (infix_expression
      left: (identifier)
      right: (number))
    fallback: (string)))

==================
Check statement — dict fallback
==================

check data else {error: "no data"}

---

(source_file
  (check_statement
    condition: (identifier)
    fallback: (dictionary_literal
      (pair
        key: (identifier)
        value: (string)))))

==================
Stop statement
==================

stop

---

(source_file
  (expression_statement
    (identifier)))

==================
Skip statement
==================

skip

---

(source_file
  (expression_statement
    (identifier)))

==================
Expression statement — function call
==================

greet("World")

---

(source_file
  (expression_statement
    (call_expression
      function: (identifier)
      arguments: (arguments
        (string)))))

==================
Expression statement — method call
==================

list.push(item)

---

(source_file
  (expression_statement
    (call_expression
      function: (member_expression
        object: (identifier)
        property: (identifier))
      arguments: (arguments
        (identifier)))))

==================
Multiple statements
==================

let x = 5
let y = 10
x + y

---

(source_file
  (let_statement
    pattern: (identifier)
    value: (number))
  (let_statement
    pattern: (identifier)
    value: (number))
  (expression_statement
    (infix_expression
      left: (identifier)
      right: (identifier))))

==================
Let with expression value
==================

let doubled = for (n in [1, 2, 3]) { n * 2 }

---

(source_file
  (let_statement
    pattern: (identifier)
    value: (for_expression
      variable: (identifier)
      iterable: (array_literal
        (number)
        (number)
        (number))
      body: (block
        (expression_statement
          (infix_expression
            left: (identifier)
            right: (number)))))))

==================
Dict destructuring with alias
==================

let {name as n, age} = person

---

(source_file
  (let_statement
    pattern: (dictionary_pattern
      key: (identifier)
      alias: (identifier)
      (identifier))
    value: (identifier)))

==================
Export dict destructuring
==================

export {a, b} = expr

---

(source_file
  (export_statement
    pattern: (dictionary_pattern
      (identifier)
      (identifier))
    value: (identifier)))
